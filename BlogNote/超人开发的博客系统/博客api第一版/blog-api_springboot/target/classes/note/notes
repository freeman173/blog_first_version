项目中的几种常见对象：
    PO:persitant object
    DO:Domain Object
    DTO：data transfer object
    VO:value object
    BO:business object
    POJO:plain ordinary java object
    DAO:data access object



@RequestBody:
    如果后端参数是一个对象，且该参数前是以@RequestBody修饰的，那么前端传递json参数时，必须满足以下要求：

    1. 后端@RequestBody注解对应的类在将HTTP的输入流(含请求体)装配到目标类时，会根据json字符串中的key来匹配对应实体类的属性，
    如果匹配一致且json中的该key对应的值符合(或可转换为) 实体类的对应属性的类型时,会调用实体类的setter方法将值赋给该属性。

    2. json字符串中，如果value为"“的话，后端对应属性如果是String类型的，那么接受到的就是”"，如果是后端属性的类型是Integer
        、Double等类型，那么接收到的就是null。

    3. json字符串中，如果value为null的话，后端对应收到的就是null。


驼峰命名法的使用：
    为了规范项目，取名字的地方基本上都用到了驼峰命名法！！




2022/4/16

完成了首页信息的显示：
    前端vue发送数据请求到articlecontroller；
    controller调用service；
    在service中：
        读取文章信息：
            借助mybatis-plus的工具（分页器、查询条件生成工具）拿到article数据；
            mybatis-plus里面的BaseMapper类帮助我们自动实现了crud操作，不需要额外的编写mapper.xml文件。
            读取出来的pojo型其实跟网页想要的有所出入？
                解决：
                    配置一个vo类型的数据，让vo去迎合前端的需求。
                    将pojo转化为vo：
                         BeanUtils：主要解决的问题是：把对象的属性数据封装到对象中。该工具提供字符式操作为对象属性提供封装。
                         BeanUtils.copyProperties如果你有两个具有很多相同属性的JavaBean，就可以用这个方法。
                            如果两个类间存在名称不相同的属性，则BeanUtils不对这些属性进行处理，需要手动处理。

                    在文章信息中，authorname在其他pojo类中，通过author_id拿到authorname：
                        这个操作简单，不再赘述！！

                    在文章信息中，tags在其他pojo类中，而且一个文章不止有一个tag！！一共涉及3张表！！
                        传入文章的id，
                        调用tagmapper（这里需要写新的接口，所以需要在resource中配置新的mapper映射文件并且要在ymal文件中配置mapper-locations）
                        得到对应的tags pojo对象后，将pojo映射为vo对象

            返回ArticleVo数据给controller！！


     controller再返给前端！



2022/4/17
    最热标签功能

从对应表中取出tag出现次数最多的前三个元素
select tag_id  from ms_article_tag group by tag_id order by count(article_id) desc  limit 3


最后一步出现bug！明天来调试一下！！




2022/4/19

    统一异常处理：
        对于后端预料之外的异常，需要统一进行处理。


    最新文章查询功能：文章日期格式这块有些疑惑：等项目敲完了，过来优化一下。


    文章归档：

    文章表做了一下变动：创建日期栏不能为空，方便归档！！

    将时间戳转换为日期格式；再从中取出年月；用年月做分类从而实现归档
select year(FROM_UNIXTIME(create_date/1000,'%y-%m-%d %h:%m:%s')) as year ,month(FROM_UNIXTIME(create_date/1000,'%y-%m-%d %h:%m:%s')) as month,count(*) as count from ms_article group by year,month

        DO:Domain Object:通过sql查询的对象（不需要持久化）




2022/4/20
    jwt:可以生成一个加密的token，用户登录成功后得到一个token；当用户请求资源时，可以凭借此令牌获取。
    jwt有三个部分：
        header：
        playload：
        签证：

    redis的使用：
        找到redis配置文件中的redis-server开启即可。（C:\Program Files\Redis）

    今日任务：登录功能，前端成功拿到token，但其中一些工具不是很熟悉!

    明天任务：完成登录功能；熟悉登录的整个流程并了解重点流程处的工具的大致原理！！



2022/4/22:
    springboot 可以通过调用service接口（框架会自动映射到对应的serviceimpl实现类）提供服务，若有多个实现类，需要具体指定是哪一个！！



redis常用操作：
    keys *：查询所有的keys

    set key value
    例如： set test test1

    get key
    例如： get test

    dbsize 键值总数
    该命令不会遍历redis， 而是直接获取redis内置的计算总数变量
    127.0.0.1:6379> dbsize
    (integer) 6

    exists key 检查key是否存在


    del key 删除

    expire key seconds 设置过期时间


    type key 返回key数据类型


登录的流程：
    前端提交用户信息到对应controller，再到login的service
    service做判断：如果数据库里有用户信息，就生成一个token，并将token（键）与用户信息（值）放入redis中，
    并返回给前端一个token。

    其他前端页面需要验证用户是否登录时：
          前端页面将token传进来，从redis中拿到用户信息即可。


    退出登录：通过前端传入的token将数据从redis中删除即可。
 注：用户信息在redis，说明用户处于登录状态！！
 心得：整个流程大致熟悉，但重要部分的工具实现不是太过清楚，等后面需要了解时，再具体了解即可！！


2022/4/24:
    注册功能已经完成。

    头像显示不出来，可能跟路径有关，这是一个bug，后面来调试
    注册的流程：
        前端将注册信息打包送到controller（service）；
        在service中：
            先做判空与数据库中是否已存在用户，若失败则返回失败信息体。
            若成功：
                创建一个空对象给它赋值并通过mapper对象存入数据库。
                生成token，并将token与用户信息存入redis。
                返回给前端token并跳转到登录页面做登录验证！
        注：回滚操作：@Transactional，当事务处理出问题时，执行回滚操作！！


2022/4/25：
    拦截器：进行登陆拦截，遇到需要登录才能访问的接口，若未登陆，则拦截器将其劝退到登录页面！

    　ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。
    在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。



2022/4/27:
    开发文章功能：
        文章表、文章体表、文章类别表、文章标签表四者相互关联：
            文章表把文章体跟类别单独摘了出来另做了一个表！（未做外键关联，这个后面再说！）


    up主的一个错误：每个文章只对应一个类别，但在articlevo中却使用了list；纠正一手。

    文章页面基本开发完毕，但是数据库中几张表的id自动生成的序号太乱看着不舒服，后面找时间来优化一下。

    文章阅读数量：
        文章阅读数量的操作采用了线程池的技术（避免影响主进程），后面有需要再去了解！


    注：在项目开发中，尽量避免使用对象数据类型，如将“int”---》“Integer”，可以避免一些bug！！


2022/4/28:


    今天把评论功能写了，但不是很清楚它的逻辑。明天来梳理一下即可。


2022/4/30:

    今天把文章界面的评论加载功能写了，做一个小小的总结：
        逻辑是这样的：
            前端将请求给到对应的controller，controller再给到对应的service；
            service：
                根据文章id去评论表中找对应的父评论（level字段为1的为父评论）；
                将数据库中的Comment对象映射为前端所需要的格式CommentVo:
                     填充子评论属性、评论者之类的信息。

                最后再返回数据。

            遇见一个小bug：子评论显示不出来。
            解决：queryWrapper.eq(Comment::getParentId,id);//将表中的父评论id字段拿出来跟评论id做对比。


    评论书写功能也写好了（评论之前需要先登录才行），但也有两个小bug：
        生成的id是分布式的，看起来非常不舒服，后面改成小一点的id生成方式！！
        评论生成之后，前端页面老是反馈评论失败，但刷新一下之后，评论可以显示出来，后面再来看！！





2022/5/01:
    文章发布功能逻辑（登录才能发布）：
        service：
            获取当前用户信息；
            构建article对象，填充基本信息并插入到表中；
            取出发布文章的标签，然后插入到文章标签表中；
            取出发布文章的body，然后插入到文章body表中；
            articleBodyId生成后，将其设置到article的属性字段中并更新article对象；
            返回给前端article的id。


    注：这个功能一路顺畅，很舒服！！





2022/5/2:
    面向切面：
        AOP是Spring框架面向切面的编程思想，AOP采用一种称为“横切”的技术，将涉及多业务流程的通用功能抽取并单独封装，
        形成独立的切面，在合适的时机将这些切面横向切入到业务流程指定的位置中。

        在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice，如事务处理、日志记录就可以理解为切面。
        切面实际就是对主业务逻辑的一种增强。
            Joint Point(连接点)：程序执行的某个特定位置。
            PointCut(切点)：指切面具体织入的位置。是一组 joint point。
            Advice(增强)：Advice是切面的一种实现，可以完成简单织入功能
                @Around：环绕增强，能控制切点执行前，执行后，，用这个注解后，程序抛异常，会影响@AfterThrowing这个注解。

            Target(目标对象)：织入 Advice 的目标对象.。
            Weaving(织入)：把切面应用到目标对象来创建新的代理对象的过程。

    记录日志案例功能:
        在controller的接口方法前添加自定义注解“@LogAnnotation”;
        为该注解添加切面功能（打印该方法相关的参数）。


    上传图片功能：
        一般上传的资源都会单独放到一个新的服务器(但是我嫌麻烦，直接放到本地就行了)
        明天再来弄！！

        图片能传到本地，url也可以访问；但还是有bug！！

        后面再来看吧，我现在已经腻了，不想再3调试了！！

    标签归档这里有bug：
        article查询这里：有些标签无对应文章，所以只能显示全部的文章，这是一个bug！后面再来改！



2022/5/4:

    文章归档：
        大体上没问题。
        但还是有小bug：
            文章的日期显示不对！
            新建的文章在阅读后，阅读量并未增加

         后面再来改！！



2022/5/5:
    cache缓存的加入：将第一次加载的页面资源放入缓存，后续访问就会比较快！！
    使用方法：cache工具类的实现原理现在暂时不用管！！在相应的controller的方法上加上@cache注解即可！

    对数据库生成的id做了一下优化：这个简单！！（只要你想，总能解决问题！！）


    后续优化：
        1、文章放入es中，便于后续分词搜索
        2、将评论数据放入mongodb中
        3、阅读数与评论数可以放入reids中自增，使用定时任务将其固化在数据库
        4、可以将前端静态资源放入专门的服务器，加快访问速度！
        5、做一个后台管理系统，方便管理后台！

        ES是一个使用java语言编写的并且基于Lucene编写的搜索引擎, 他提供了分布式的全文搜索服务,
    还提供了一个RESTful风格的web接口, 官方还对多种语言提供了相应的API。
        MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。
    它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。

        MongoDB中的记录是一个文档，它是由字段和值对组成的数据结构。
        多个键及其关联的值有序地放在一起就构成了文档。
        MongoDB文档类似于JSON对象。
        集合就是一组文档，类似于关系数据库中的表。多个集合组成数据库。



2022/5/12
    回来优化项目:

        头像问题：注册时让用户自己从系统中随机选择一个即可.（解决了）

        文章日期的问题：解决。


    明天优化：
        新建的文章，阅读数量不增加!

        个人名片这里需要改进：谁登录，就用谁的

        优化成功！！


2022/5/13:

    文章评论完成啦！！


    文章上传图片功能看一下：上传到本地即可！！
        图片上传到本地，将图片的映射地址返回给前端，让前端通过地址访问即可！
            逻辑没问题，博主也是这个逻辑，浏览器输入图片的映射地址也能访问。但后台就是报错，搞不懂！！



2022/7/4:
    搞了半天，前后端远程调用一直没解决，真的烦!
    数据库调用服务器的也行！

    今天结果：前后端还是在同一主机即可（等后面项目开发完之后再来弄），数据库使用服务器上的就行！

2022/7/6:
    新增加一个功能：登录之后可以查看并修改自己的文章。
    没改出来；
    大致逻辑：
           调用文章接口里面加一个姓名参数传到后端；后端做一个查询操作即可！明天来

2022/7/7:
    功能已完成大半：
        bug：登录认证有些问题；；旁边的日期归档有些小问题




2022/7/13:

    问题大体上解决！
    把写文章时上传图片的功能再来实现一下！！


2022/7/14:

    上传图片这里：整了半天，把接口上的打印功能关掉后，就解决了！（问题已经解决，具体原理不清楚，后面需要多少再来拿多少！）

    再加一个修改文章的功能。




2022/7/15:
    博客api功能可以了！


2022/7/19:
    docker部署后面再来！



2022/7/20:
    docker部署java项目已经成功了一大半：
        跟mysql与redis接口的对接出现了一点问题，明天再来弄

2022/7/22:

  前端vue部署到Nginx了，接口这块有点问题！！

2022/7/23:

    docker上，vue跟springboot的接口始终对接不上，难受的一批！


2022/7/25

    开始做笔记总结了，做到登录功能了。
    明天争取把api整个系统总结完毕。
